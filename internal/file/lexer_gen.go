// Code generated by Participle. DO NOT EDIT.
package file

import (
	"fmt"
	"io"
	"strings"
	"sync"
	"unicode/utf8"
	"regexp/syntax"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var _ syntax.Op
var _ fmt.State
const _ = utf8.RuneError

var GenBackRefCache sync.Map
var GenLexer lexer.Definition = lexerGenDefinitionImpl{}

type lexerGenDefinitionImpl struct {}

func (lexerGenDefinitionImpl) Symbols() map[string]lexer.TokenType {
	return map[string]lexer.TokenType{
      "Attribute": -7,
      "EOF": -1,
      "Numeral": -4,
      "ParenClose": -9,
      "ParenOpen": -8,
      "StringLit": -5,
      "Symbol": -6,
      "Version": -3,
      "Whitespace": -2,
	}
}

func (lexerGenDefinitionImpl) LexString(filename string, s string) (lexer.Lexer, error) {
	return &lexerGenImpl{
		s: s,
		pos: lexer.Position{
			Filename: filename,
			Line:     1,
			Column:   1,
		},
		states: []lexerGenState{ {name: "Root"} },
	}, nil
}

func (d lexerGenDefinitionImpl) LexBytes(filename string, b []byte) (lexer.Lexer, error) {
	return d.LexString(filename, string(b))
}

func (d lexerGenDefinitionImpl) Lex(filename string, r io.Reader) (lexer.Lexer, error) {
	s := &strings.Builder{}
	_, err := io.Copy(s, r)
	if err != nil {
		return nil, err
	}
	return d.LexString(filename, s.String())
}

type lexerGenState struct {
	name    string
	groups  []string
}

type lexerGenImpl struct {
	s       string
	p       int
	pos     lexer.Position
	states  []lexerGenState
}

func (l *lexerGenImpl) Next() (lexer.Token, error) {
	if l.p == len(l.s) {
		return lexer.EOFToken(l.pos), nil
	}
	var (
		state = l.states[len(l.states)-1]
		groups []int
		sym lexer.TokenType
	)
	switch state.name {
	case "Root":if match := matchGenWhitespace(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -2
			groups = match[:]
		} else if match := matchGenVersion(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -3
			groups = match[:]
		} else if match := matchGenNumeral(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -4
			groups = match[:]
		} else if match := matchGenStringLit(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -5
			groups = match[:]
		} else if match := matchGenSymbol(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -6
			groups = match[:]
		} else if match := matchGenAttribute(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -7
			groups = match[:]
		} else if match := matchGenParenOpen(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -8
			groups = match[:]
		} else if match := matchGenParenClose(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -9
			groups = match[:]
		}
	}
	if groups == nil {
		sample := []rune(l.s[l.p:])
		if len(sample) > 16 {
			sample = append(sample[:16], []rune("...")...)
		}
		return lexer.Token{}, participle.Errorf(l.pos, "invalid input text %q", string(sample))
	}
	pos := l.pos
	span := l.s[groups[0]:groups[1]]
	l.p = groups[1]
	l.pos.Advance(span)
	return lexer.Token{
		Type:  sym,
		Value: span,
		Pos:   pos,
	}, nil
}

func (l *lexerGenImpl) sgroups(match []int) []string {
	sgroups := make([]string, len(match)/2)
	for i := 0; i < len(match)-1; i += 2 {
		sgroups[i/2] = l.s[l.p+match[i]:l.p+match[i+1]]
	}
	return sgroups
}
// [\t-\n\r ]+
func matchGenWhitespace(s string, p int, backrefs []string) (groups [2]int) {
// [\t-\n\r ] (CharClass)
l0 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '\t' && rn <= '\n': return p+1
case rn == '\r': return p+1
case rn == ' ': return p+1
}
return -1
}
// [\t-\n\r ]+ (Plus)
l1 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
for len(s) > p {
if np := l0(s, p); np == -1 { return p } else { p = np }
}
return p
}
np := l1(s, p)
if np == -1 {
  return
}
groups[0] = p
groups[1] = np
return
}

// (0|[1-9][0-9]*)\.(0|[1-9][0-9]*)
func matchGenVersion(s string, p int, backrefs []string) (groups [6]int) {
// 0 (Literal)
l0 := func(s string, p int) int {
if p < len(s) && s[p] == '0' { return p+1 }
return -1
}
// [1-9] (CharClass)
l1 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '1' && rn <= '9': return p+1
}
return -1
}
// [0-9] (CharClass)
l2 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '0' && rn <= '9': return p+1
}
return -1
}
// [0-9]* (Star)
l3 := func(s string, p int) int {
for len(s) > p {
if np := l2(s, p); np == -1 { return p } else { p = np }
}
return p
}
// [1-9][0-9]* (Concat)
l4 := func(s string, p int) int {
if p = l1(s, p); p == -1 { return -1 }
if p = l3(s, p); p == -1 { return -1 }
return p
}
// 0|[1-9][0-9]* (Alternate)
l5 := func(s string, p int) int {
if np := l0(s, p); np != -1 { return np }
if np := l4(s, p); np != -1 { return np }
return -1
}
// (0|[1-9][0-9]*) (Capture)
l6 := func(s string, p int) int {
np := l5(s, p)
if np != -1 {
  groups[2] = p
  groups[3] = np
}
return np}
// \. (Literal)
l7 := func(s string, p int) int {
if p < len(s) && s[p] == '.' { return p+1 }
return -1
}
// (0|[1-9][0-9]*)\.(0|[1-9][0-9]*) (Concat)
l8 := func(s string, p int) int {
if p = l6(s, p); p == -1 { return -1 }
if p = l7(s, p); p == -1 { return -1 }
if p = l6(s, p); p == -1 { return -1 }
return p
}
np := l8(s, p)
if np == -1 {
  return
}
groups[0] = p
groups[1] = np
return
}

// 0|[1-9][0-9]*
func matchGenNumeral(s string, p int, backrefs []string) (groups [2]int) {
// 0 (Literal)
l0 := func(s string, p int) int {
if p < len(s) && s[p] == '0' { return p+1 }
return -1
}
// [1-9] (CharClass)
l1 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '1' && rn <= '9': return p+1
}
return -1
}
// [0-9] (CharClass)
l2 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '0' && rn <= '9': return p+1
}
return -1
}
// [0-9]* (Star)
l3 := func(s string, p int) int {
for len(s) > p {
if np := l2(s, p); np == -1 { return p } else { p = np }
}
return p
}
// [1-9][0-9]* (Concat)
l4 := func(s string, p int) int {
if p = l1(s, p); p == -1 { return -1 }
if p = l3(s, p); p == -1 { return -1 }
return p
}
// 0|[1-9][0-9]* (Alternate)
l5 := func(s string, p int) int {
if np := l0(s, p); np != -1 { return np }
if np := l4(s, p); np != -1 { return np }
return -1
}
np := l5(s, p)
if np == -1 {
  return
}
groups[0] = p
groups[1] = np
return
}

// "([^"]|"")*"
func matchGenStringLit(s string, p int, backrefs []string) (groups [4]int) {
// " (Literal)
l0 := func(s string, p int) int {
if p < len(s) && s[p] == '"' { return p+1 }
return -1
}
// [^"] (CharClass)
l1 := func(s string, p int) int {
if len(s) <= p { return -1 }
var (rn rune; n int)
if s[p] < utf8.RuneSelf {
  rn, n = rune(s[p]), 1
} else {
  rn, n = utf8.DecodeRuneInString(s[p:])
}
switch {
case rn >= '\x00' && rn <= '!': return p+1
case rn >= '#' && rn <= '\U0010ffff': return p+n
}
return -1
}
// "" (Literal)
l2 := func(s string, p int) int {
if p+2 <= len(s) && s[p:p+2] == "\"\"" { return p+2 }
return -1
}
// [^"]|"" (Alternate)
l3 := func(s string, p int) int {
if np := l1(s, p); np != -1 { return np }
if np := l2(s, p); np != -1 { return np }
return -1
}
// ([^"]|"") (Capture)
l4 := func(s string, p int) int {
np := l3(s, p)
if np != -1 {
  groups[2] = p
  groups[3] = np
}
return np}
// ([^"]|"")* (Star)
l5 := func(s string, p int) int {
for len(s) > p {
if np := l4(s, p); np == -1 { return p } else { p = np }
}
return p
}
// "([^"]|"")*" (Concat)
l6 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
if p = l5(s, p); p == -1 { return -1 }
if p = l0(s, p); p == -1 { return -1 }
return p
}
np := l6(s, p)
if np == -1 {
  return
}
groups[0] = p
groups[1] = np
return
}

// \|[^\\\|]*\||[!\$-&\*-\+\--/<-Z\^-_a-z~][!\$-&\*-\+\--9<-Z\^-_a-z~]*
func matchGenSymbol(s string, p int, backrefs []string) (groups [2]int) {
// \| (Literal)
l0 := func(s string, p int) int {
if p < len(s) && s[p] == '|' { return p+1 }
return -1
}
// [^\\\|] (CharClass)
l1 := func(s string, p int) int {
if len(s) <= p { return -1 }
var (rn rune; n int)
if s[p] < utf8.RuneSelf {
  rn, n = rune(s[p]), 1
} else {
  rn, n = utf8.DecodeRuneInString(s[p:])
}
switch {
case rn >= '\x00' && rn <= '[': return p+1
case rn >= ']' && rn <= '{': return p+1
case rn >= '}' && rn <= '\U0010ffff': return p+n
}
return -1
}
// [^\\\|]* (Star)
l2 := func(s string, p int) int {
for len(s) > p {
if np := l1(s, p); np == -1 { return p } else { p = np }
}
return p
}
// \|[^\\\|]*\| (Concat)
l3 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
if p = l2(s, p); p == -1 { return -1 }
if p = l0(s, p); p == -1 { return -1 }
return p
}
// [!\$-&\*-\+\--/<-Z\^-_a-z~] (CharClass)
l4 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn == '!': return p+1
case rn >= '$' && rn <= '&': return p+1
case rn >= '*' && rn <= '+': return p+1
case rn >= '-' && rn <= '/': return p+1
case rn >= '<' && rn <= 'Z': return p+1
case rn >= '^' && rn <= '_': return p+1
case rn >= 'a' && rn <= 'z': return p+1
case rn == '~': return p+1
}
return -1
}
// [!\$-&\*-\+\--9<-Z\^-_a-z~] (CharClass)
l5 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn == '!': return p+1
case rn >= '$' && rn <= '&': return p+1
case rn >= '*' && rn <= '+': return p+1
case rn >= '-' && rn <= '9': return p+1
case rn >= '<' && rn <= 'Z': return p+1
case rn >= '^' && rn <= '_': return p+1
case rn >= 'a' && rn <= 'z': return p+1
case rn == '~': return p+1
}
return -1
}
// [!\$-&\*-\+\--9<-Z\^-_a-z~]* (Star)
l6 := func(s string, p int) int {
for len(s) > p {
if np := l5(s, p); np == -1 { return p } else { p = np }
}
return p
}
// [!\$-&\*-\+\--/<-Z\^-_a-z~][!\$-&\*-\+\--9<-Z\^-_a-z~]* (Concat)
l7 := func(s string, p int) int {
if p = l4(s, p); p == -1 { return -1 }
if p = l6(s, p); p == -1 { return -1 }
return p
}
// \|[^\\\|]*\||[!\$-&\*-\+\--/<-Z\^-_a-z~][!\$-&\*-\+\--9<-Z\^-_a-z~]* (Alternate)
l8 := func(s string, p int) int {
if np := l3(s, p); np != -1 { return np }
if np := l7(s, p); np != -1 { return np }
return -1
}
np := l8(s, p)
if np == -1 {
  return
}
groups[0] = p
groups[1] = np
return
}

// :[!\$-&\*-\+\--/<-Z\^-_a-z~][!\$-&\*-\+\--9<-Z\^-_a-z~]*
func matchGenAttribute(s string, p int, backrefs []string) (groups [2]int) {
// : (Literal)
l0 := func(s string, p int) int {
if p < len(s) && s[p] == ':' { return p+1 }
return -1
}
// [!\$-&\*-\+\--/<-Z\^-_a-z~] (CharClass)
l1 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn == '!': return p+1
case rn >= '$' && rn <= '&': return p+1
case rn >= '*' && rn <= '+': return p+1
case rn >= '-' && rn <= '/': return p+1
case rn >= '<' && rn <= 'Z': return p+1
case rn >= '^' && rn <= '_': return p+1
case rn >= 'a' && rn <= 'z': return p+1
case rn == '~': return p+1
}
return -1
}
// [!\$-&\*-\+\--9<-Z\^-_a-z~] (CharClass)
l2 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn == '!': return p+1
case rn >= '$' && rn <= '&': return p+1
case rn >= '*' && rn <= '+': return p+1
case rn >= '-' && rn <= '9': return p+1
case rn >= '<' && rn <= 'Z': return p+1
case rn >= '^' && rn <= '_': return p+1
case rn >= 'a' && rn <= 'z': return p+1
case rn == '~': return p+1
}
return -1
}
// [!\$-&\*-\+\--9<-Z\^-_a-z~]* (Star)
l3 := func(s string, p int) int {
for len(s) > p {
if np := l2(s, p); np == -1 { return p } else { p = np }
}
return p
}
// :[!\$-&\*-\+\--/<-Z\^-_a-z~][!\$-&\*-\+\--9<-Z\^-_a-z~]* (Concat)
l4 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
if p = l1(s, p); p == -1 { return -1 }
if p = l3(s, p); p == -1 { return -1 }
return p
}
np := l4(s, p)
if np == -1 {
  return
}
groups[0] = p
groups[1] = np
return
}

// \(
func matchGenParenOpen(s string, p int, backrefs []string) (groups [2]int) {
if p < len(s) && s[p] == '(' {
groups[0] = p
groups[1] = p + 1
}
return
}

// \)
func matchGenParenClose(s string, p int, backrefs []string) (groups [2]int) {
if p < len(s) && s[p] == ')' {
groups[0] = p
groups[1] = p + 1
}
return
}
